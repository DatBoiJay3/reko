typedef long BPTR;
[[reko::amiga_function_vector(ExecLibrary,-480)]] [[reko::returns(register,"D0")]] BYTE AbortIO([[reko::arg(register,"A1")]] struct IORequest * iORequest);
[[reko::amiga_function_vector(ExecLibrary,-432)]] void AddDevice([[reko::arg(register,"A1")]] struct Device * device);
[[reko::amiga_function_vector(ExecLibrary,-240)]] void AddHead([[reko::arg(register,"A0")]] struct List * list,[[reko::arg(register,"A1")]] struct Node * node);
[[reko::amiga_function_vector(ExecLibrary,-168)]] void AddIntServer([[reko::arg(register,"D0",0,4)]] ULONG intNum,[[reko::arg(register,"A1")]] struct Interrupt * interrupt);
[[reko::amiga_function_vector(ExecLibrary,-396)]] void AddLibrary([[reko::arg(register,"A1")]] struct Library * library);
[[reko::amiga_function_vector(ExecLibrary,-618)]] void AddMemList([[reko::arg(register,"D0")]] ULONG size,[[reko::arg(register,"D1")]] ULONG attributes,[[reko::arg(register,"D2")]] LONG pri,[[reko::arg(register,"A0")]] APTR base,[[reko::arg(register,"A1")]] char * name);
[[reko::amiga_function_vector(ExecLibrary,-354)]] void AddPort([[reko::arg(register,"A1")]] struct MsgPort * port);
[[reko::amiga_function_vector(ExecLibrary,-486)]] void AddResource([[reko::arg(register,"A1")]] APTR resource);
[[reko::amiga_function_vector(ExecLibrary,-600)]] void AddSemaphore([[reko::arg(register,"A1")]] struct SignalSemaphore * signalSemaphore);
[[reko::amiga_function_vector(ExecLibrary,-246)]] void AddTail([[reko::arg(register,"A0")]] struct List * list,[[reko::arg(register,"A1")]] struct Node * node);
[[reko::amiga_function_vector(ExecLibrary,-282)]] void AddTask([[reko::arg(register,"A1")]] struct Task * task,[[reko::arg(register,"A2")]] APTR initialPC,[[reko::arg(register,"A3")]] APTR finalPC);
[[reko::amiga_function_vector(ExecLibrary,-108)]] void Alert([[reko::arg(register,"D7")]] ULONG alertNum,[[reko::arg(register,"A5")]] APTR parameters);
[[reko::amiga_function_vector(ExecLibrary,-204)]] [[reko::returns(register,"D0")]] void * AllocAbs([[reko::arg(register,"D0")]] ULONG byteSize,[[reko::arg(register,"A1")]] APTR location);
[[reko::amiga_function_vector(ExecLibrary,-186)]] [[reko::returns(register,"D0")]] void * Allocate([[reko::arg(register,"A0")]] struct MemHeader * MemHeader,[[reko::arg(register,"D0")]] ULONG byteSize);
[[reko::amiga_function_vector(ExecLibrary,-222)]] [[reko::returns(register,"D0")]] struct MemList * AllocEntry([[reko::arg(register,"A0")]] struct MemList * memList);
[[reko::amiga_function_vector(ExecLibrary,-198)]] [[reko::returns(register,"D0")]] void * AllocMem([[reko::arg(register,"D0")]] ULONG byteSize,[[reko::arg(register,"D1")]] ULONG attributes);
[[reko::amiga_function_vector(ExecLibrary,-330)]] [[reko::returns(register,"D0")]] BYTE AllocSignal([[reko::arg(register,"D0")]] LONG signalNum);
[[reko::amiga_function_vector(ExecLibrary,-342)]] [[reko::returns(register,"D0")]] LONG AllocTrap([[reko::arg(register,"D0")]] LONG trapNum);
[[reko::amiga_function_vector(ExecLibrary,-576)]] [[reko::returns(register,"D0")]] LONG AttemptSemaphore([[reko::arg(register,"A0")]] struct SignalSemaphore * signalSemaphore);
[[reko::amiga_function_vector(ExecLibrary,-216)]] [[reko::returns(register,"D0")]] ULONG AvailMem([[reko::arg(register,"D1")]] ULONG attributes);
[[reko::amiga_function_vector(ExecLibrary,-180)]] void Cause([[reko::arg(register,"A1")]] struct Interrupt * interrupt);
[[reko::amiga_function_vector(ExecLibrary,-468)]] [[reko::returns(register,"D0")]] BOOL CheckIO([[reko::arg(register,"A1")]] struct IORequest * iORequest);
[[reko::amiga_function_vector(ExecLibrary,-450)]] void CloseDevice([[reko::arg(register,"A1")]] struct IORequest * iORequest);
[[reko::amiga_function_vector(ExecLibrary,-414)]] void CloseLibrary([[reko::arg(register,"A1")]] struct Library * library);
[[reko::amiga_function_vector(ExecLibrary,-624)]] void CopyMem([[reko::arg(register,"A0")]] APTR source,[[reko::arg(register,"A1")]] APTR dest,[[reko::arg(register,"D0")]] ULONG size);
[[reko::amiga_function_vector(ExecLibrary,-630)]] void CopyMemQuick([[reko::arg(register,"A0")]] ULONG * source,[[reko::arg(register,"A1")]] ULONG * dest,[[reko::arg(register,"D0")]] ULONG size);
[[reko::amiga_function_vector(ExecLibrary,-192)]] void Deallocate([[reko::arg(register,"A0")]] struct MemHeader * MemHeader,[[reko::arg(register,"A1")]] APTR memoryBlock,[[reko::arg(register,"D0")]] ULONG byteSize);
[[reko::amiga_function_vector(ExecLibrary,-114)]] void Debug([[reko::arg(register,"D0")]] ULONG unused);
[[reko::amiga_function_vector(ExecLibrary,-120)]] void Disable(void);
[[reko::amiga_function_vector(ExecLibrary,-456)]] [[reko::returns(register,"D0")]] BYTE DoIO([[reko::arg(register,"A1")]] struct IORequest * iORequest);
[[reko::amiga_function_vector(ExecLibrary,-126)]] void Enable(void);
[[reko::amiga_function_vector(ExecLibrary,-270)]] void Enqueue([[reko::arg(register,"A0")]] struct List * list,[[reko::arg(register,"A1")]] struct Node * node);
[[reko::amiga_function_vector(ExecLibrary,-276)]] [[reko::returns(register,"D0")]] struct Node * FindName([[reko::arg(register,"A0")]] struct List * start,[[reko::arg(register,"A1")]] char * name);
[[reko::amiga_function_vector(ExecLibrary,-390)]] [[reko::returns(register,"D0")]] struct MsgPort * FindPort([[reko::arg(register,"A1")]] char * name);
[[reko::amiga_function_vector(ExecLibrary,-96)]] [[reko::returns(register,"D0")]] struct Resident * FindResident([[reko::arg(register,"A1")]] char * name);
[[reko::amiga_function_vector(ExecLibrary,-594)]] [[reko::returns(register,"D0")]] struct SignalSemaphore * FindSemaphore([[reko::arg(register,"A1")]] char * name);
[[reko::amiga_function_vector(ExecLibrary,-294)]] [[reko::returns(register,"D0")]] struct Task * FindTask([[reko::arg(register,"A1")]] char * name);
[[reko::amiga_function_vector(ExecLibrary,-132)]] void Forbid(void);
[[reko::amiga_function_vector(ExecLibrary,-228)]] void FreeEntry([[reko::arg(register,"A0")]] struct MemList * memList);
[[reko::amiga_function_vector(ExecLibrary,-210)]] void FreeMem([[reko::arg(register,"A1")]] void * memoryBlock,[[reko::arg(register,"D0")]] ULONG byteSize);
[[reko::amiga_function_vector(ExecLibrary,-336)]] void FreeSignal([[reko::arg(register,"D0")]] ULONG signalNum);
[[reko::amiga_function_vector(ExecLibrary,-348)]] void FreeTrap([[reko::arg(register,"D0")]] ULONG trapNum);
[[reko::amiga_function_vector(ExecLibrary,-528)]] [[reko::returns(register,"D0")]] UWORD GetCC(void);
[[reko::amiga_function_vector(ExecLibrary,-372)]] [[reko::returns(register,"D0")]] struct Message * GetMsg([[reko::arg(register,"A0")]] struct MsgPort * port);
[[reko::amiga_function_vector(ExecLibrary,-72)]] void InitCode([[reko::arg(register,"D0")]] ULONG startClass,[[reko::arg(register,"D1")]] ULONG version);
[[reko::amiga_function_vector(ExecLibrary,-102)]] void InitResident([[reko::arg(register,"A1")]] struct Resident * resident,[[reko::arg(register,"D1")]] BPTR segList);
[[reko::amiga_function_vector(ExecLibrary,-558)]] void InitSemaphore([[reko::arg(register,"A0")]] struct SignalSemaphore * signalSemaphore);
[[reko::amiga_function_vector(ExecLibrary,-78)]] void InitStruct([[reko::arg(register,"A1")]] struct InitStruct * initTable,[[reko::arg(register,"A2")]] APTR memory,[[reko::arg(register,"D0")]] ULONG size);
[[reko::amiga_function_vector(ExecLibrary,-234)]] void Insert([[reko::arg(register,"A0")]] struct List * list,[[reko::arg(register,"A1")]] struct Node * node,[[reko::arg(register,"A2")]] struct Node * listNode);
[[reko::amiga_function_vector(ExecLibrary,-90)]] [[reko::returns(register,"D0")]] ULONG MakeFunctions([[reko::arg(register,"A0")]] APTR target,[[reko::arg(register,"A1")]] APTR functionArray,[[reko::arg(register,"A2")]] APTR funcDispBase);
[[reko::amiga_function_vector(ExecLibrary,-84)]] [[reko::returns(register,"D0")]] struct Library * MakeLibrary([[reko::arg(register,"A0")]] APTR vectors,[[reko::arg(register,"A1")]] struct InitStruct * structure,[[reko::arg(register,"A2")]] APTR init,[[reko::arg(register,"D0")]] ULONG dSize,[[reko::arg(register,"D1")]] BPTR segList);
[[reko::amiga_function_vector(ExecLibrary,-564)]] void ObtainSemaphore([[reko::arg(register,"A0")]] struct SignalSemaphore * signalSemaphore);
[[reko::amiga_function_vector(ExecLibrary,-582)]] void ObtainSemaphoreList([[reko::arg(register,"A0")]] struct List * list);
[[reko::amiga_function_vector(ExecLibrary,-408)]] [[reko::returns(register,"D0")]] struct Library * OldOpenLibrary([[reko::arg(register,"A1")]] APTR libName);
[[reko::amiga_function_vector(ExecLibrary,-444)]] [[reko::returns(register,"D0")]] BYTE OpenDevice([[reko::arg(register,"A0")]] char * devName,[[reko::arg(register,"D0")]] ULONG unitNumber,[[reko::arg(register,"A1")]] struct IORequest * iORequest,[[reko::arg(register,"D1")]] ULONG flags);
[[reko::amiga_function_vector(ExecLibrary,-552)]] [[reko::returns(register,"D0")]] struct Library * OpenLibrary([[reko::arg(register,"A1")]] char * libName,[[reko::arg(register,"D0")]] ULONG version);
[[reko::amiga_function_vector(ExecLibrary,-498)]] [[reko::returns(register,"D0")]] APTR OpenResource([[reko::arg(register,"A1")]] char * resName);
[[reko::amiga_function_vector(ExecLibrary,-138)]] void Permit(void);
[[reko::amiga_function_vector(ExecLibrary,-540)]] [[reko::returns(register,"D0")]] BYTE Procure([[reko::arg(register,"A0")]] struct Semaphore * semaphore,[[reko::arg(register,"A1")]] struct Message * bidMessage);
[[reko::amiga_function_vector(ExecLibrary,-366)]] void PutMsg([[reko::arg(register,"A0")]] struct MsgPort * port,[[reko::arg(register,"A1")]] struct Message * message);
[[reko::amiga_function_vector(ExecLibrary,-522)]] void RawDoFmt([[reko::arg(register,"A0")]] char * FormatString,[[reko::arg(register,"A1")]] APTR DataStream,[[reko::arg(register,"A2")]] void (*PutChProc)(),[[reko::arg(register,"A3")]] APTR PutChData);
[[reko::amiga_function_vector(ExecLibrary,-570)]] void ReleaseSemaphore([[reko::arg(register,"A0")]] struct SignalSemaphore * signalSemaphore);
[[reko::amiga_function_vector(ExecLibrary,-588)]] void ReleaseSemaphoreList([[reko::arg(register,"A0")]] struct List * list);
[[reko::amiga_function_vector(ExecLibrary,-438)]] void RemDevice([[reko::arg(register,"A1")]] struct Device * device);
[[reko::amiga_function_vector(ExecLibrary,-258)]] [[reko::returns(register,"D0")]] struct Node * RemHead([[reko::arg(register,"A0")]] struct List * list);
[[reko::amiga_function_vector(ExecLibrary,-174)]] void RemIntServer([[reko::arg(register,"D0")]] ULONG intNum,[[reko::arg(register,"A1")]] struct Interrupt * interrupt);
[[reko::amiga_function_vector(ExecLibrary,-402)]] void RemLibrary([[reko::arg(register,"A1")]] struct Library * library);
[[reko::amiga_function_vector(ExecLibrary,-252)]] void Remove([[reko::arg(register,"A1")]] struct Node * node);
[[reko::amiga_function_vector(ExecLibrary,-360)]] void RemPort([[reko::arg(register,"A1")]] struct MsgPort * port);
[[reko::amiga_function_vector(ExecLibrary,-492)]] void RemResource([[reko::arg(register,"A1")]] APTR resource);
[[reko::amiga_function_vector(ExecLibrary,-606)]] void RemSemaphore([[reko::arg(register,"A1")]] struct SignalSemaphore * signalSemaphore);
[[reko::amiga_function_vector(ExecLibrary,-264)]] [[reko::returns(register,"D0")]] struct Node * RemTail([[reko::arg(register,"A0")]] struct List * list);
[[reko::amiga_function_vector(ExecLibrary,-288)]] void RemTask([[reko::arg(register,"A1")]] struct Task * task);
[[reko::amiga_function_vector(ExecLibrary,-378)]] void ReplyMsg([[reko::arg(register,"A1")]] struct Message * message);
[[reko::amiga_function_vector(ExecLibrary,-462)]] void SendIO([[reko::arg(register,"A1")]] struct IORequest * iORequest);
[[reko::amiga_function_vector(ExecLibrary,-312)]] [[reko::returns(register,"D0")]] ULONG SetExcept([[reko::arg(register,"D0")]] ULONG newSignals,[[reko::arg(register,"D1")]] ULONG signalMask);
[[reko::amiga_function_vector(ExecLibrary,-420)]] [[reko::returns(register,"D0")]] APTR SetFunction([[reko::arg(register,"A1")]] struct Library * library,[[reko::arg(register,"A0.W")]] LONG funcOffset,[[reko::arg(register,"D0")]] APTR funcEntry);
[[reko::amiga_function_vector(ExecLibrary,-162)]] [[reko::returns(register,"D0")]] struct Interrupt * SetIntVector([[reko::arg(register,"D0",0,4)]] ULONG intNumber,[[reko::arg(register,"A1")]] struct Interrupt * interrupt);
[[reko::amiga_function_vector(ExecLibrary,-306)]] [[reko::returns(register,"D0")]] ULONG SetSignal([[reko::arg(register,"D0")]] ULONG newSignals,[[reko::arg(register,"D1")]] ULONG signalMask);
[[reko::amiga_function_vector(ExecLibrary,-144)]] [[reko::returns(register,"D0")]] ULONG SetSR([[reko::arg(register,"D0")]] ULONG newSR,[[reko::arg(register,"D1")]] ULONG mask);
[[reko::amiga_function_vector(ExecLibrary,-300)]] [[reko::returns(register,"D0",0,8)]] BYTE SetTaskPri([[reko::arg(register,"A1")]] struct Task * task,[[reko::arg(register,"D0",0,8)]] LONG priority);
[[reko::amiga_function_vector(ExecLibrary,-324)]] void Signal([[reko::arg(register,"A1")]] struct Task * task,[[reko::arg(register,"D0")]] ULONG signals);
[[reko::amiga_function_vector(ExecLibrary,-612)]] void SumKickData(void);
[[reko::amiga_function_vector(ExecLibrary,-426)]] void SumLibrary([[reko::arg(register,"A1")]] struct Library * library);
[[reko::amiga_function_vector(ExecLibrary,-150)]] [[reko::returns(register,"D0")]] APTR SuperState(void);
[[reko::amiga_function_vector(ExecLibrary,-534)]] [[reko::returns(register,"D0")]] ULONG TypeOfMem([[reko::arg(register,"A1")]] void * address);
[[reko::amiga_function_vector(ExecLibrary,-156)]] void UserState([[reko::arg(register,"D0")]] APTR sysStack);
[[reko::amiga_function_vector(ExecLibrary,-546)]] void Vacate([[reko::arg(register,"A0")]] struct Semaphore * semaphore);
[[reko::amiga_function_vector(ExecLibrary,-318)]] [[reko::returns(register,"D0")]] ULONG Wait([[reko::arg(register,"D0")]] ULONG signalSet);
[[reko::amiga_function_vector(ExecLibrary,-474)]] [[reko::returns(register,"D0")]] BYTE WaitIO([[reko::arg(register,"A1")]] struct IORequest * iORequest);
[[reko::amiga_function_vector(ExecLibrary,-384)]] [[reko::returns(register,"D0")]] struct Message * WaitPort([[reko::arg(register,"A0")]] struct MsgPort * port);
