typedef long BPTR;
 [[reko::amiga_function_vector(DosLibrary,-36)]]  void  Close( [[reko::arg(register,"D1")]] struct FileHandle *file );
 [[reko::amiga_function_vector(DosLibrary,-120)]]  [[reko::return(register,"D0")]]  struct FileLock * CreateDir( [[reko::arg(register,"D1")]] char *name );
 [[reko::amiga_function_vector(DosLibrary,-138)]]  [[reko::return(register,"D0")]]  struct Process * CreateProc( [[reko::arg(register,"D1")]] char *name,[[reko::arg(register,"D2")]] LONG pri,[[reko::arg(register,"D3")]] BPTR *segment,[[reko::arg(register,"D4")]] LONG stackSize );
 [[reko::amiga_function_vector(DosLibrary,-126)]]  [[reko::return(register,"D0")]]  struct FileLock * CurrentDir( [[reko::arg(register,"D1")]] struct FileLock *lock );
 [[reko::amiga_function_vector(DosLibrary,-192)]]  void  DateStamp( [[reko::arg(register,"D1")]] LONG *v );
 [[reko::amiga_function_vector(DosLibrary,-198)]]  void  Delay( [[reko::arg(register,"D1")]] LONG ticks );
 [[reko::amiga_function_vector(DosLibrary,-72)]]  [[reko::return(register,"D0")]]  BOOL  DeleteFile( [[reko::arg(register,"D1")]] char *name );
 [[reko::amiga_function_vector(DosLibrary,-174)]]  [[reko::return(register,"D0")]]  struct Process * DeviceProc( [[reko::arg(register,"D1")]] char *name );
 [[reko::amiga_function_vector(DosLibrary,-96)]]  [[reko::return(register,"D0")]]  struct FileLock * DupLock( [[reko::arg(register,"D1")]] struct FileLock *lock );
 [[reko::amiga_function_vector(DosLibrary,-102)]]  [[reko::return(register,"D0")]]  BOOL  Examine( [[reko::arg(register,"D1")]] struct FileLock *lock,[[reko::arg(register,"D2")]] struct FileInfoBlock *infoBlock );
 [[reko::amiga_function_vector(DosLibrary,-222)]]  [[reko::return(register,"D0")]]  BOOL  Execute( [[reko::arg(register,"D1")]] char *commandString,[[reko::arg(register,"D2")]] struct FileHandle *input,[[reko::arg(register,"D3")]] struct FileHandle *output );
 [[reko::amiga_function_vector(DosLibrary,-144)]]  void  Exit( [[reko::arg(register,"D1")]] LONG returnCode );
 [[reko::amiga_function_vector(DosLibrary,-108)]]  [[reko::return(register,"D0")]]  BOOL  ExNext( [[reko::arg(register,"D1")]] struct FileLock *lock,[[reko::arg(register,"D2")]] struct FileInfoBlock *infoBlock );
 [[reko::amiga_function_vector(DosLibrary,-114)]]  [[reko::return(register,"D0")]]  BOOL  Info( [[reko::arg(register,"D1")]] struct FileLock *lock,[[reko::arg(register,"D2")]] struct InfoData *parameterBlock );
 [[reko::amiga_function_vector(DosLibrary,-132)]]  [[reko::return(register,"D0")]]  LONG  IoErr(  );
 [[reko::amiga_function_vector(DosLibrary,-54)]]  [[reko::return(register,"D0")]]  struct FileHandle * Input(  );
 [[reko::amiga_function_vector(DosLibrary,-216)]]  [[reko::return(register,"D0")]]  BOOL  IsInteractive( [[reko::arg(register,"D1")]] struct FileHandle *file );
 [[reko::amiga_function_vector(DosLibrary,-150)]]  [[reko::return(register,"D0")]]  BPTR  LoadSeg( [[reko::arg(register,"D1")]] char *name );
 [[reko::amiga_function_vector(DosLibrary,-84)]]  [[reko::return(register,"D0")]]  struct FileLock * Lock( [[reko::arg(register,"D1")]] char *name,[[reko::arg(register,"D2")]] LONG accessMode );
 [[reko::amiga_function_vector(DosLibrary,-30)]]  [[reko::return(register,"D0")]]  struct FileHandle * Open( [[reko::arg(register,"D1")]] char *name,[[reko::arg(register,"D2")]] LONG accessMode );
 [[reko::amiga_function_vector(DosLibrary,-60)]]  [[reko::return(register,"D0")]]  struct FileHandle * Output(  );
 [[reko::amiga_function_vector(DosLibrary,-210)]]  [[reko::return(register,"D0")]]  struct FileLock * ParentDir( [[reko::arg(register,"D1")]] struct FileLock *lock );
 [[reko::amiga_function_vector(DosLibrary,-42)]]  [[reko::return(register,"D0")]]  LONG  Read( [[reko::arg(register,"D1")]] struct FileHandle *file,[[reko::arg(register,"D2")]] char *buffer,[[reko::arg(register,"D3")]] LONG length );
 [[reko::amiga_function_vector(DosLibrary,-78)]]  [[reko::return(register,"D0")]]  BOOL  Rename( [[reko::arg(register,"D1")]] char *oldName,[[reko::arg(register,"D2")]] char *newName );
 [[reko::amiga_function_vector(DosLibrary,-66)]]  [[reko::return(register,"D0")]]  LONG  Seek( [[reko::arg(register,"D1")]] struct FileHandle *file,[[reko::arg(register,"D2")]] LONG position,[[reko::arg(register,"D3")]] LONG mode );
 [[reko::amiga_function_vector(DosLibrary,-180)]]  [[reko::return(register,"D0")]]  BOOL  SetComment( [[reko::arg(register,"D1")]] char *name,[[reko::arg(register,"D2")]] char *comment );
 [[reko::amiga_function_vector(DosLibrary,-186)]]  [[reko::return(register,"D0")]]  BOOL  SetProtection( [[reko::arg(register,"D1")]] char *name,[[reko::arg(register,"D2:4")]] LONG mask );
 [[reko::amiga_function_vector(DosLibrary,-156)]]  [[reko::return(register,"D0")]]  BOOL  UnLoadSeg( [[reko::arg(register,"D1")]] BPTR segment );
 [[reko::amiga_function_vector(DosLibrary,-90)]]  void  UnLock( [[reko::arg(register,"D1")]] struct FileLock *lock );
 [[reko::amiga_function_vector(DosLibrary,-204)]]  [[reko::return(register,"D0")]]  BOOL  WaitForChar( [[reko::arg(register,"D1")]] struct FileHandle *file,[[reko::arg(register,"D2")]] LONG timeout );
 [[reko::amiga_function_vector(DosLibrary,-48)]]  [[reko::return(register,"D0")]]  LONG  Write( [[reko::arg(register,"D1")]] struct FileHandle *file,[[reko::arg(register,"D2")]] char *buffer,[[reko::arg(register,"D3")]] LONG length );
